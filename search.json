[{"title":"Git学习","path":"/2025/05/12/git-study/","content":"自用常用命令 常用命令 git status 可以查看当前状态 git log 查看提交版本链 （其中HEAD指向当前版本） git log –graph –pretty&#x3D;oneline –abbrev-commit 简略版本变化，也可以查看分支合并情况 版本选择 git reset –hard HEAD^回退到上一个版本。 git reflog 记录了每次commit的记录 可以配合git reset –hard “commit id”指定版本 git diff HEAD -- 文件名命令可以查看工作区和版本库里面最新版本的区别： 补充 git diff 工作区 vs 暂存区 git diff --cached 暂存区 vs 上次提交 git diff HEAD 工作区 vs 上次提交 撤销缓存区修改 git restore readme.txt 工作区中的修改尚未被提交到暂存区，撤销修改： git restore –staged readme.txt将修改从暂存区撤除 工作区中的修改已被提交到暂存区，尚未被提交到本地仓库，撤销修改： 删除文件（本地仓库） git rm test.txt 相当于是删除工作目录中的test.txt文件,并把此次删除操作提交到了暂存区 使用rm file 可以使用git restore file进行恢复，但是如果提交git rm file，则不可以了，需要如下命令 git restore –staged file git restore file git checkout – readme.txt 从一个版本中恢复删除的文件 初始化仓库 git remote add origin xxx.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 git push -u origin master 将当前master分支推送到远程仓库。加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 之后提交 git push origin master 查看本地仓库连接信息 git remote -v 查看远程仓库信息 git remote rm xx 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。 创建分支 git brach dev 创建 git checkout dev 切换到dev 简化 git checkout -b dev git brach 查看当前分支 合并分支 如果创建分支并进行修改，切换到别的分支，是看不见新分支上的内容的。 例如，创建dev分支。提交了1.txt文件，切换到master分支上是没有1.txt文件的 可以将dev分支结果合并到master分支 git merge dev = git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 删除分支 git branch -d xxx 切换分支也可以使用switch git switch -c dev 创建并切换到新的dev分支，可以使用 git switch master 切换分支 合并分支冲突 git merge dev （当前master） 冲突的话 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存 之后提交保存后的文件 git add 和git commi 分支管理 git merge –no-ff -m “merge with no-ff” dev Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 解决原先的合并发至导致的dev分支删除情况，即无法查看分支的信息了 bug分支 ：将当前分支“储存起来”,创建新分支解决bug，完了后恢复现场(如果是另一个分支修改文件，是不可以直接切换分支的) git stash 可以使用多次，保存多个状态信息 $ git stash list 查看 stash@{0}: WIP on dev: c36220d test bug stash@{1}: WIP on dev: c36220d test bug 恢复 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了 git stash apply stash@{0} 恢复到指定的stash 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 清除 git stash clear git stash drop stash@{1} git stash drop (最近一次） 多人协作 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支 如果远程存在dev分支，可以创建远程origin的dev分支到本地 git checkout -b dev origin&#x2F;master 如果远程没有dev分支，需要创建分支并推送 1234567# 创建本地分支 dev，并从主分支 main/master 上拉出来git checkout -b dev main# 或者git checkout -b dev origin/maingit push -u origin dev 多人协作的工作模式通常是这样： 首先，可以尝试用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 注册因为要配置用户名和账号信息 123git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 如果你想查看当前仓库中（即局部配置）的用户信息，可以使用不带 --global 的版本： 12git config user.namegit config user.email 如果你想查看所有当前生效的 Git 配置信息（包括系统级、全局级、仓库级），可以使用： 1git config --list 这将列出所有 Git 配置项及其当前值。如果有多个层级的配置（如局部覆盖了全局），则显示生效的那个。 使用初始化一个项目在当前文件夹下 1git init 添加文件到暂存区1git add &quot;file&quot; / git add ./ 要查看 Git 暂存区（staging area） 的文件，可以使用以下命令： 1git status 这个命令会列出： 已添加到暂存区、准备提交的文件（显示为“changes to be committed”）。 已修改但尚未加入暂存区的文件（显示为“changes not staged for commit”）。 未被跟踪的新文件（显示为“untracked files”）。 如果你只想列出已加入暂存区的文件：1git diff --cached --name-only 解释： --cached：表示查看暂存区与上一次提交之间的差异。 --name-only：只显示文件名，不显示具体的 diff 内容。 如果你想查看这些文件的具体改动内容：1git diff --cached 这个命令会显示暂存区中文件相对于最近一次提交的具体差异（diff）。 是否需要演示一个完整的工作流示例？ 提交到仓库1git commit -m &quot;注释&quot; 具体案例好的，这里是一个 完整的 Git 工作流示例，包括文件的创建、修改、添加到暂存区、查看暂存区内容等操作，适合理解 Git 各个阶段的变化。 ✅ 初始准备 创建一个新的 Git 仓库（如果没有仓库的话）： 123mkdir demo-repocd demo-repogit init 📝 步骤 1：创建并编辑文件1echo &quot;Hello Git&quot; &gt; file.txt 此时，file.txt 是一个新文件，尚未被 Git 跟踪。 🔍 步骤 2：查看当前状态1git status 输出类似： 123Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) file.txt ➕ 步骤 3：将文件添加到暂存区1git add file.txt 🔍 步骤 4：再次查看状态1git status 输出类似： 123Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: file.txt 此时 file.txt 已经在暂存区中。 👁️ 步骤 5：查看暂存区内容 查看已暂存文件名： 1git diff --cached --name-only 输出： 1file.txt 查看暂存区的实际改动内容： 1git diff --cached ✅ 步骤 6：提交暂存区的更改1git commit -m &quot;Add file.txt&quot; 🌀 可选：修改文件并观察状态变化12echo &quot;New line&quot; &gt;&gt; file.txtgit status 输出将显示 file.txt 被修改但尚未再次加入暂存区。 版本管理 常用的版本回退 使用git log可以查看当前提交版本情况 12345678910111213141516171819$ git logcommit e487ae96fda82c3b8ad5e148fb0d835e8ffdf023 (HEAD -&gt; master)Author: xx &lt;xx@qq.com&gt;Date: Sun May 11 16:24:12 2025 +0800 第三次尝试commit bab0c45fea79dd42b7be8ff6a89b1d5786c244b9Author: xx &lt;xx@qq.com&gt;Date: Sun May 11 15:54:31 2025 +0800 appendcommit 3d3b7ea699cdc96bc98c2f7f2def2bda1ae09fdaAuthor: xx &lt;xx@qq.com&gt;Date: Sun May 11 15:52:25 2025 +0800 write a readme file 可以使用git reset –hard HEAD^回退到上一个版本。 --hard参数有啥意义？--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。 这里回退后结果 123456789101112commit bab0c45fea79dd42b7be8ff6a89b1d5786c244b9 (HEAD -&gt; master)Author: xx &lt;xx@qq.com&gt;Date: Sun May 11 15:54:31 2025 +0800 appendcommit 3d3b7ea699cdc96bc98c2f7f2def2bda1ae09fdaAuthor: xx &lt;xx@qq.com&gt;Date: Sun May 11 15:52:25 2025 +0800 write a readme file 也可以使用git reset –hard e487ae 回退到之前的版本 管理和修改Git跟踪并管理的是修改，而非文件 （也就是修改一个字符也会跟踪） 撤销修改(缓存区）如果想撤销暂存区(git add）内部的文件，可以使用下面的命令 1234567891011121314151617181920$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: test new file: test.txt$ git restore --staged test$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: test.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test 1、工作区中的修改尚未被提交到暂存区，撤销修改：git restore readme.txt 2、工作区中的修改已被提交到暂存区，尚未被提交到本地仓库，撤销修改：git restore –staged readme.txt将修改从暂存区撤除，然后再用git restore readme.txt将修改从工作区撤除。 3、修改已被提交到本地仓库，撤销修改：假如该次提交只提交了这一个修改，则可用git reset –hard CommitID恢复到提交前的版本。也可以用git revert命令反转该次提交。 但是如果该次提交涉及了多个文件的多处修改，这样操作会将其他的修改一并清除。此时我们可以用git reset命令指明文件和预期的恢复ID来将修改从暂存区中移除。例如git reset HEAD^ readme.txt是将此文件恢复到次新版。然后git restore readme.txt将修改从工作区撤除。然后再git commit -m msg提交到本地仓库 查看文件是否修改 命令 比较内容 git diff 工作区 vs 暂存区 git diff --cached 暂存区 vs 上次提交 git diff HEAD 工作区 vs 上次提交 删除文件 (本地仓库) 本地删除 rm file git status可以查看删除了什么 git rm file git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的。 git commit -m “” 提交到本地仓库 1234567891011121314151617181920212223ccc@cccwl MINGW32 /d/project/git_study/sty_one (master)$ rm 11.txtccc@cccwl MINGW32 /d/project/git_study/sty_one (master)$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: 11.txtChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: 11.txt $ git rm 11.txtrm &#x27;11.txt&#x27;$ git commit -m &quot;remove 11.txt&quot;[master d2e6dc0] remove 11.txt 1 file changed, 1 deletion(-) delete mode 100644 11.txt 分情况说明如何恢复被 git rm 删除的文件： 1)情况 1：删除后还没提交如果你运行了： 1git rm readme.txt 但**还没运行 ****git commit**，你可以直接恢复文件： 1git restore readme.txt 这会从上次提交中恢复被删除的文件（即恢复到 HEAD 状态）。 2)情况 2：删除后已经提交 可用如果你运行了： 12git rm readme.txtgit commit -m &quot;删除了 readme.txt&quot; 你可以通过以下方式恢复该文件： 方法 A：恢复文件到工作区（从历史版本中 checkout 出来） 1git checkout HEAD^ -- readme.txt 解释： HEAD^ 表示上一个提交； -- readme.txt 表示只恢复这个文件。 ✅ 恢复后该文件会重新出现在工作区，你可以再次 git add 和 git commit 来重新添加它。 方法 B（更通用）：查看历史版本并恢复指定提交中的文件 查看提交历史，找到删除前的提交： 1git log -- readme.txt 按下 q 退出日志界面。 使用你想恢复的提交哈希： 1git checkout &lt;commit_id&gt; -- readme.txt 🔁 小结 操作场景 恢复命令 删除未提交 git restore readme.txt 删除并已提交 git checkout HEAD^ -- readme.txt 或指定 commit 恢复 恢复整个版本 git checkout &lt;commit_id&gt;（慎用，会切换整个项目状态） 需要我帮你生成一个示例，演示如何完整地删掉并恢复一个文件的全过程吗？ 分支管理 重点添加远程仓库 git remote add origin xxx.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 git push -u origin master 将当前master分支推送到远程仓库。加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 git push origin master 之后提交 删除远程仓库git remote -v 查看远程仓库信息 git remote rm xx 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。 创建合并分支git brach dev 创建 git checkout dev 切换到dev 简化 git checkout -b dev git brach 查看当前分支 如果创建分支并进行修改，切换到别的分支，是看不见新分支上的内容的。 例如，创建dev分支。提交了1.txt文件，切换到master分支上是没有1.txt文件的 可以将dev分支结果合并到master分支 git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 解决冲突主要是两个或多个分支代码冲突，需要手动修改 git merge dev （当前master） 如果冲突，可以看到使用git status查看冲突文件 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 具体文件内容 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存 之后提交保存后的文件 git add 和git commi 分支管理git merge –no-ff -m “merge with no-ff” dev Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 如果使用原先的merge，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 bug分支bug分支 ：将当前分支“储存起来”,创建新分支解决bug，完了后恢复现场(如果是另一个分支修改文件，是不可以直接切换分支的) git stash 可以使用多次，保存多个状态信息 $ git stash list 查看 stash@{0}: WIP on dev: c36220d test bug stash@{1}: WIP on dev: c36220d test bug 恢复 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了 git stash apply stash@{0} 恢复到指定的stash 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 feature分支新功能在新的分支上进行 多人协作1git push origin master 1git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支 如果远程存在dev分支，可以创建远程origin的dev分支到本地 git checkout -b dev origin&#x2F;master 如果远程没有dev分支，需要创建分支并推送 1234567# 创建本地分支 dev，并从主分支 main/master 上拉出来git checkout -b dev main# 或者git checkout -b dev origin/maingit push -u origin dev 多人协作的工作模式通常是这样： 首先，可以尝试用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。","tags":["Git"],"categories":["Git"]},{"title":"Hello World","path":"/2025/05/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"这里写关于页的正文，支持 Markdown, HTML"}]